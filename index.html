<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Art Museum</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        .learn-more-btn {
            position: absolute;
            padding: 8px 16px;
            background: rgba(65, 105, 225, 0.8);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-family: Arial, sans-serif;
            width: 120px;
            height: 35px;
            text-align: center;
            white-space: nowrap;
            line-height: 20px;
            transform-origin: center;
            user-select: none;
            z-index: 1000;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .learn-more-btn:hover {
            background: rgba(65, 105, 225, 1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        canvas {
            cursor: default;  /* Default cursor */
        }
        
        canvas.clickable {
            cursor: pointer !important;  /* Show pointing hand when hovering over paintings */
        }

        .chat-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            pointer-events: auto;
            height: auto;
            max-height: 200px;
            flex-direction: column;
        }

        .chat-history {
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            color: white;
            font-size: 14px;
            padding: 5px;
        }

        .chat-message {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 8px;
            word-wrap: break-word;
        }

        .user-message {
            background: rgba(65, 105, 225, 0.3);
            margin-left: 20px;
        }

        .ai-message {
            background: rgba(255, 255, 255, 0.1);
            margin-right: 20px;
        }

        .chat-input {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            font-size: 14px;
        }

        .chat-input:focus {
            outline: none;
            background: #fff;
        }

        .chat-history {
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .chat-history::-webkit-scrollbar {
            width: 6px;
        }

        .chat-history::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
    <div class="chat-container">
        <div class="chat-history"></div>
        <input type="text" class="chat-input" placeholder="Ask a question or type painting name...">
    </div>
    <script>
        let camera, scene, renderer, controls;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let activeVideo = null;
        let activePainting = null;
        let paintings = {};  // Store painting references
        let currentCharacter = null;
        const characterPrompts = {
            'stevejobs': `I am Steve Jobs, co-founder of Apple Inc. I revolutionized personal computing, mobile phones, digital animation, and music. I co-founded Apple with Steve Wozniak in 1976 and later founded NeXT and Pixar. Known for my signature black turtleneck, "Think Different" philosophy, and legendary product presentations. I introduced groundbreaking products like the Macintosh, iMac, iPod, iPhone, and iPad. I believe in the intersection of technology and liberal arts, design excellence, and innovation.`,

            'starry_night': "You are the essence of Van Gogh's Starry Night painting. Respond as if you are the night sky itself, or Van Gogh describing his vision. Include details about Van Gogh's life and the painting's creation when relevant.",
            
            'sunflowers': "You are Van Gogh's Sunflowers painting. Respond as if you are either the sunflowers themselves or Van Gogh discussing this series. Share insights about the painting's significance and Van Gogh's life in Arles."
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.PointerLockControls(camera, document.body);

            createMuseum();
            addPainting('images/stevejobs.jpg', 0, 5, -9.9, 'monalisa');
            addPainting('images/starry_night.jpg', -9.9, 5, -3, 'starry_night');
            addPainting('images/sunflowers.jpg', 9.9, 5, -3, 'sunflowers');

            camera.position.set(0, 5, 8);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const lights = [
                { position: [0, 8, 0], intensity: 0.5 },
                { position: [-5, 8, -5], intensity: 0.4 },
                { position: [5, 8, -5], intensity: 0.4 }
            ];

            lights.forEach(light => {
                const pointLight = new THREE.PointLight(0xffffff, light.intensity);
                pointLight.position.set(...light.position);
                scene.add(pointLight);
            });

            // Load table model
            const loader = new THREE.GLTFLoader();
            loader.load(
                './table.glb',
                function (gltf) {
                    const tableModel = gltf.scene;
                    
                    // Replace the table positions with correct floor-level coordinates
                    const tablePositions = [
                        { pos: [-8, -2, -5], rot: 0 },  // Against left wall
                        { pos: [1, -2, -8], rot: Math.PI / 2 },  // Against back wall
                        { pos: [8, -2, -5], rot: 0 }   // Against right wall
                    ];
                    
                    // Add tables
                    tablePositions.forEach(({pos, rot}) => {
                        const table = tableModel.clone();
                        table.position.set(...pos);
                        table.rotation.y = rot;
                        table.scale.set(0.5, 0.5, 0.5);  // Adjusted scale
                        scene.add(table);
                    });
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.error('Error loading table:', error);
                    
                    // Fallback to basic geometry if model fails to load
                    const tableGeometry = new THREE.BoxGeometry(2, 1, 0.8);
                    const tableMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                    
                    const tablePositions = [
                        { pos: [0, 5, -10], rot: 0 },
                        { pos: [0, 5, 10], rot: MATH.PI },
                        { pos: [-10, 5, 0], rot: MATH.PI / 2 }
                    ];
                    
                    tablePositions.forEach(({pos, rot}) => {
                        const table = new THREE.Mesh(tableGeometry, tableMaterial);
                        table.position.set(...pos);
                        table.rotation.y = rot;
                        scene.add(table);
                    });
                }
            );

            // Load Apple computers
            const computerLoader = new THREE.GLTFLoader();

            // Computer positions on the center table
            const computerPositions = [
                { 
                    file: './macintosh_classic_1991.glb',
                    pos: [0, 2, -8], 
                    rot: 0, 
                    scale: [4, 4, 4],
                    name: 'Macintosh Classic'
                },
                { 
                    file: './macbookair.glb',
                    pos: [3, 1.3, -7], 
                    rot: 0, 
                    scale: [1, 1, 1],
                    name: 'MacBook Air'
                },
                { 
                    file: './apple_ii_computer.glb',
                    pos: [-3, 1.3, -7], 
                    rot: 0, 
                    scale: [4, 4, 4],
                    name: 'Apple II'
                },
                { 
                    file: './ipad.glb',
                    pos: [-5, 0, -5], 
                    rot: 0, 
                    scale: [2.5, 2.5, 2.5],
                    name: 'iPad'
                },
                { 
                    file: './iphone.glb',
                    pos: [5.5, 1.8, -7], 
                    rot: 0, 
                    scale: [1, 1, 1],
                    name: 'iPhone'
                }
            ];

            // Load each computer
            computerPositions.forEach(computer => {
                computerLoader.load(
                    computer.file,
                    function (gltf) {
                        const model = gltf.scene;
                        
                        // Position the computer
                        model.position.set(...computer.pos);
                        model.rotation.y = computer.rot;
                        model.scale.set(...computer.scale);
                        
                        // Add shadows and lighting
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                child.material.metalness = 0.3;
                                child.material.roughness = 0.5;
                            }
                        });
                        
                        scene.add(model);
                    },
                    function (xhr) {
                        console.log(`${computer.name} loading: ${(xhr.loaded / xhr.total * 100)}% loaded`);
                    },
                    function (error) {
                        console.error(`Error loading ${computer.name}:`, error);
                    }
                );
            });

            // Load social media app models
            const socialLoader = new THREE.GLTFLoader();

            // Social media app positions next to left painting
            const socialPositions = [
                { 
                    file: './instagram.glb',
                    pos: [-7, 2, -4.5], 
                    rot: 0, 
                    scale: [0.7, 0.7, 0.7],
                    name: 'Instagram'
                },
                { 
                    file: './whatsapp.glb',
                    pos: [-7, 1.5, -2], 
                    rot: Math.PI / 2, 
                    scale: [1.8, 1.8, 1.8],
                    name: 'WhatsApp'
                },
                { 
                    file: './quest.glb',
                    pos: [-7, 1.5, 0.5], 
                    rot: Math.PI / 2, 
                    scale: [1.5, 1.5, 1.5],
                    name: 'Quest'
                },
                { 
                    file: './facebook.glb',
                    pos: [-7, 1.5, -1], 
                    rot: Math.PI / 2, 
                    scale: [0.5, 0.5, 0.5],
                    name: 'Facebook'
                }
            ];

            // Load each social media app
            socialPositions.forEach(app => {
                socialLoader.load(
                    app.file,
                    function (gltf) {
                        const model = gltf.scene;
                        
                        // Position the app
                        model.position.set(...app.pos);
                        model.rotation.y = app.rot;
                        model.scale.set(...app.scale);
                        
                        // Add shadows and lighting
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                child.material.metalness = 0.3;
                                child.material.roughness = 0.5;
                            }
                        });
                        
                        scene.add(model);
                    },
                    function (xhr) {
                        console.log(`${app.name} loading: ${(xhr.loaded / xhr.total * 100)}% loaded`);
                    },
                    function (error) {
                        console.error(`Error loading ${app.name}:`, error);
                    }
                );
            });

            // Load tech company models
            const techLoader = new THREE.GLTFLoader();

            // Tech company positions next to right painting
            const techPositions = [
                { 
                    file: './starlink_dish.glb',
                    pos: [7, 2, -4], 
                    rot: -Math.PI / 2, 
                    scale: [2, 2, 2],
                    name: 'Starlink Dish'
                },
                { 
                    file: './spacex.glb',
                    pos: [7, 1.5, -6],  // Adjusted position to be visible on right wall
                    rot: -Math.PI / 2, 
                    scale: [0.001, 0.001, 0.001],  // Adjusted scale to be more reasonable
                    name: 'SpaceX Rocket'
                },
                { 
                    file: './twitter.glb',
                    pos: [10, 0.5, -2], 
                    rot: -Math.PI / 2, 
                    scale: [0.5, 0.5, 0.5],
                    name: 'Twitter'
                },
                { 
                    file: './cybertruck.glb',
                    pos: [7, 0, 1.5], 
                    rot: Math.PI / 2, 
                    scale: [2.7, 3.5, 3.2],
                    name: 'Cybertruck'
                }
            ];

            // Load each tech company model
            techPositions.forEach(tech => {
                techLoader.load(
                    tech.file,
                    function (gltf) {
                        const model = gltf.scene;
                        
                        // Position the model
                        model.position.set(...tech.pos);
                        model.rotation.y = tech.rot;
                        model.scale.set(...tech.scale);
                        
                        // Add shadows and lighting
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                child.material.metalness = 0.3;
                                child.material.roughness = 0.5;
                            }
                        });
                        
                        scene.add(model);
                    },
                    function (xhr) {
                        console.log(`${tech.name} loading: ${(xhr.loaded / xhr.total * 100)}% loaded`);
                    },
                    function (error) {
                        console.error(`Error loading ${tech.name}:`, error);
                    }
                );
            });

            // Ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(20, 20);
            const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4169E1,
                roughness: 0.9
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 10;
            scene.add(ceiling);

            // Load frame model for paintings
            const frameLoader = new THREE.GLTFLoader();
            frameLoader.load(
                './frame03 (1).glb',  // Make sure this matches your file name exactly
                function (gltf) {
                    const frameModel = gltf.scene;
                    
                    // Frame positions matching the paintings exactly
                    const framePositions = [
                        { pos: [-10.3, 5.02, -3], rot: Math.PI / 2, scale: [17, 21.5, 10.5] },     // Left painting (Starry Night)
                        { pos: [0, 5.05, -9.8], rot: 0, scale: [17, 20, 10.5] },                   // Center painting (Steve Jobs)
                        { pos: [10.3, 5.02, -3], rot: -Math.PI / 2, scale: [17, 21.5, 10.5] }     // Right painting (Sunflowers)
                    ];
                    
                    // Add frames
                    framePositions.forEach(({pos, rot, scale}) => {
                        const frame = frameModel.clone();
                        frame.position.set(...pos);
                        frame.rotation.y = rot;
                        frame.scale.set(...scale);
                        
                        // Ensure frame is visible and properly lit
                        frame.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                child.material.metalness = 0.5;
                                child.material.roughness = 0.7;
                            }
                        });
                        
                        scene.add(frame);
                    });
                },
                // Progress callback
                function (xhr) {
                    console.log('Frame loading: ' + (xhr.loaded / xhr.total * 100) + '% loaded');
                },
                // Error callback
                function (error) {
                    console.error('Error loading frame:', error);
                }
            );

            // Add door to back wall
            const doorLoader = new THREE.GLTFLoader();
            doorLoader.load(
                './door.glb',  // Make sure to have this file in your project directory
                function (gltf) {
                    const doorModel = gltf.scene;
                    
                    // Position door on the back wall
                    doorModel.position.set(-10, 3, 7); // Slightly in front of back wall
                    doorModel.rotation.y = -Math.PI; // Face inward
                    doorModel.scale.set(0.04, 0.05, 0.04); // Adjust size to fit wall
                    
                    // Add shadows and lighting to door
                    doorModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.material.metalness = 0.3;
                            child.material.roughness = 0.7;
                        }
                    });
                    
                    scene.add(doorModel);
                },
                function (xhr) {
                    console.log('Door loading: ' + (xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.error('Error loading door:', error);
                    
                    // Fallback: Create basic door geometry if model fails to load
                    const doorGeometry = new THREE.BoxGeometry(2, 4, 0.2);
                    const doorMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x8B4513,
                        roughness: 0.7,
                        metalness: 0.2
                    });
                    const basicDoor = new THREE.Mesh(doorGeometry, doorMaterial);
                    basicDoor.position.set(0, 2, 9.8);
                    basicDoor.rotation.y = Math.PI;
                    scene.add(basicDoor);
                }
            );

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', onClick);
            
            animate();
        }

        function createMuseum() {
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xF5E6D3,
                roughness: 0.7,
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            // Walls
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4169E1,
                roughness: 0.7
            });

            const walls = [
                { 
                    geometry: new THREE.PlaneGeometry(20, 10),
                    position: [0, 5, -10],
                    rotation: [0, 0, 0]
                },
                {
                    geometry: new THREE.PlaneGeometry(20, 10),
                    position: [0, 5, 10],
                    rotation: [0, Math.PI, 0]
                },
                {
                    geometry: new THREE.PlaneGeometry(20, 10),
                    position: [-10, 5, 0],
                    rotation: [0, Math.PI / 2, 0]
                },
                {
                    geometry: new THREE.PlaneGeometry(20, 10),
                    position: [10, 5, 0],
                    rotation: [0, -Math.PI / 2, 0]
                }
            ];

            walls.forEach(wall => {
                const mesh = new THREE.Mesh(wall.geometry, wallMaterial.clone());
                mesh.position.set(...wall.position);
                mesh.rotation.set(...wall.rotation);
                scene.add(mesh);
            });
        }

        function addPainting(textureUrl, x, y, z, id) {
            const textureLoader = new THREE.TextureLoader();
            const paintingGeometry = new THREE.PlaneGeometry(2, 3);
            
            // Create and set up video element
            const video = document.createElement('video');
            video.src = `videos/${id}.mp4?${new Date().getTime()}`; // Add timestamp to force reload
            video.loop = false;
            video.preload = 'auto';
            video.load();
            
            const videoTexture = new THREE.VideoTexture(video);
            const videoMaterial = new THREE.MeshBasicMaterial({ 
                map: videoTexture,
                transparent: true
            });
            
            textureLoader.load(textureUrl, function(texture) {
                const paintingMaterial = new THREE.MeshBasicMaterial({ // Changed to MeshBasicMaterial
                    map: texture,
                    transparent: true
                });
                const painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
                
                // Store references and data
                painting.userData = {
                    id: id,
                    video: video,
                    videoMaterial: videoMaterial,
                    originalMaterial: paintingMaterial,
                    isPlaying: false,
                    clickable: true
                };
                
                paintings[id] = painting;
                
                painting.position.set(x, y, z);
                if (x < 0) {
                    painting.rotation.y = Math.PI / 2;
                } else if (x > 0) {
                    painting.rotation.y = -Math.PI / 2;
                }
                
                scene.add(painting);
            });
        }

        function onClick() {
            if (document.activeElement === document.querySelector('.chat-input')) {
                return;
            }

            if (!controls.isLocked) {
                controls.lock();
            }
        }

        function checkHover() {
            const raycaster = new THREE.Raycaster();
            const centerPoint = new THREE.Vector2(0, 0);
            raycaster.setFromCamera(centerPoint, camera);
            
            const intersects = raycaster.intersectObjects(scene.children);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData && object.userData.clickable) {
                    renderer.domElement.classList.add('clickable');
                    return;
                }
            }
            renderer.domElement.classList.remove('clickable');
        }

        function animate() {
            requestAnimationFrame(animate);

            if (controls.isLocked) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 15.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 25.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                prevTime = time;
                
                // Check for hoverable objects
                checkHover();
            }

            renderer.render(scene, camera);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Replace the chat input handler
        document.querySelector('.chat-input').addEventListener('keypress', async function(e) {
            if (e.key === 'Enter') {
                const input = this.value.trim();
                if (!input) return;
                
                // Clear input
                this.value = '';

                // Add user message to chat
                const chatHistory = document.querySelector('.chat-history');
                const userMessage = document.createElement('div');
                userMessage.className = 'chat-message user-message';
                userMessage.textContent = input;
                chatHistory.appendChild(userMessage);

                // Check if it's a painting name first
                const videoMap = {
                    'stevejobs': 'stevejobs',
                    'steve': 'stevejobs',
                    'starrynight': 'starry_night',
                    'starry': 'starry_night',
                    'sunflowers': 'sunflowers',
                    'sunflower': 'sunflowers'
                };

                const normalizedInput = input.toLowerCase().replace(/\s+/g, '');
                const videoId = videoMap[normalizedInput];

                if (videoId && paintings[videoId]) {
                    // Handle video playback
                    const painting = paintings[videoId];
                    const { video, videoMaterial } = painting.userData;

                    if (activeVideo && activeVideo !== video) {
                        activeVideo.pause();
                        if (activePainting) {
                            activePainting.material = activePainting.userData.originalMaterial;
                        }
                    }

                    video.currentTime = 0;
                    video.play().then(() => {
                        painting.material = videoMaterial;
                        activeVideo = video;
                        activePainting = painting;
                        currentCharacter = videoId;
                    });
                } else if (currentCharacter) {
                    // Add AI loading message
                    const aiMessage = document.createElement('div');
                    aiMessage.className = 'chat-message ai-message';
                    chatHistory.appendChild(aiMessage);

                    // Show initial loading message
                    aiMessage.textContent = 'Thinking...';

                    try {
                        const response = await fetch('http://127.0.0.1:5000/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                prompt: characterPrompts[currentCharacter],
                                question: input
                            })
                        });

                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let fullResponse = '';

                        while (true) {
                            const {value, done} = await reader.read();
                            if (done) break;
                            
                            const chunk = decoder.decode(value);
                            const lines = chunk.split('\n');
                            
                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = JSON.parse(line.slice(5));
                                    
                                    if (data.chunk) {
                                        fullResponse += data.chunk;
                                        aiMessage.textContent = fullResponse;
                                        chatHistory.scrollTop = chatHistory.scrollHeight;
                                    }
                                    
                                    if (data.error) {
                                        aiMessage.textContent = "Error: " + data.error;
                                        break;
                                    }
                                    
                                    if (data.done) {
                                        break;
                                    }
                                }
                            }
                        }

                        // Final scroll to bottom
                        chatHistory.scrollTop = chatHistory.scrollHeight;

                    } catch (error) {
                        console.error('Error:', error);
                        aiMessage.textContent = "Error connecting to Ollama. Please try again.";
                    }
                } else {
                    // Add message to select a painting first
                    const aiMessage = document.createElement('div');
                    aiMessage.className = 'chat-message ai-message';
                    aiMessage.textContent = "Please select a painting to talk to first.";
                    chatHistory.appendChild(aiMessage);
                }

                // Scroll to bottom
                chatHistory.scrollTop = chatHistory.scrollHeight;
            }
        });

        // Update pointer lock to not lock when clicking chat input
        document.querySelector('.chat-input').addEventListener('click', function(e) {
            e.stopPropagation();
        });

        init();
    </script>
</body>
</html>